<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"
    integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/2.3.1/jsencrypt.min.js"
    integrity="sha512-zDvrqenA0eFJZCxBsryzUZcvihvNlEXbteMv62yRxdhR4s7K1aaz+LjsRyfk6M+YJLyAJEuuquIAI8I8GgLC8A=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
  <script>
    const saltItem = localStorage.getItem('salt'); // salt 난수 생성
    const secretKey = "YrvfhEoPhjAGC28R1q78zkD2ydrEcIxs"; // aes secret key -> 추후 env 설정 
    // iv salt 값 환경변수 사용 불가로 static
    const aesIv = {
      words: [253549881, 4056367361, 3393244246, 1194387562],
      sigBytes: 16
    }.toString(CryptoJS.enc.Hex);
    let macAddr = null;
    let serverPk = null;
    let decodeStr = null;
    let originSecretKey = null;

    // 로컬스토리지 없을 경우, 생성
    if (!saltItem) {
      const salt = CryptoJS.lib.WordArray.random(128 / 8).toString(CryptoJS.enc.Hex);
      localStorage.setItem('salt', salt);
    };

    /** 서버로부터 mac 주소(aes256), pk 요청 */
    const getdata = async () => await fetch('http://localhost:3002/getMac', {
        method: 'POST',
        body: JSON.stringify({ saltItem }),
        headers: {
          'Content-Type': 'application/json'
        }
      })
        .then(response => response.json())
        .then(res => { return res.macAddress })
        .catch(err => console.log('err', err));

    /** pk 추출 */
    const getPkData = async () => await fetch('http://localhost:3002/getPk')
      .then(response => response.json())
      .then(res => { return res.pk })
      .catch(err => console.log('err', err));

    /** aes 디코딩 */
    const aes256Decode = (data, secretKey, Iv) => {
      const cipher = CryptoJS.AES.decrypt(
        data,
        CryptoJS.enc.Utf8.parse(secretKey),
        {
          iv: CryptoJS.enc.Utf8.parse(Iv),
          padding: CryptoJS.pad.Pkcs7,
          mode: CryptoJS.mode.CBC,
        }
      );
      decodeStr = cipher.toString(CryptoJS.enc.Utf8);
    };

    /** 
     * SHA3 사용 해시값 생성 (Dv || Salt)
     * 고유식별정보, 비밀키, salt(iv)
    */
    const getHash2sha3 = async (sourceData, salt) => {
      return await CryptoJS.SHA3(sourceData + salt, { outputLength: 256 }).toString(CryptoJS.enc.Hex);
    };

    // decoding
    getdata().then(res => {
      aes256Decode(res, secretKey, saltItem);
      console.log(decodeStr);
      macAddr = res;
    });

    /** data hash 처리 및 db 전달 */
    const hashData = async (mac, pk, salt) => {
      const sha3Hash = await getHash2sha3(macAddr, saltItem); // 해시값 (Dv, salt);
      console.log(sha3Hash);
      /** aes - test */
      // const cipher = await CryptoJS.AES.encrypt(sha3Hash, pk, { iv: salt }); // 암호화
      // console.log(cipher.toString())
      // const decrypt = await CryptoJS.AES.decrypt(cipher, pk, { iv: salt }); // 복호화 test
      // console.log(decrypt.toString());

      /** 서버로부터 받은 PK를 이용한 해시값(Dv||Salt) 암호화 */
      const encryptor = new JSEncrypt();
      encryptor.setPublicKey(pk);
      const encrypted = encryptor.encrypt(sha3Hash);
      console.log('암호화된 해시값:', encrypted);
      console.log('암호화된 mac 주소:', mac);

      /** 암호문 서버 전송 및 데이터베이스 저장 */
      await fetch('http://localhost:3002/setDb', {
        method: 'POST',
        body: JSON.stringify({
          enc: encrypted
        }),
        headers: {
          'Content-Type': 'application/json'
        }
      })
        .then(response => response.json())
        .then(res => {
          console.log(res);
          localStorage.setItem('encryptedId', res.id); // 전달받은 id 로컬스토리지 저장
        })
        .catch(err => {
          console.log('db 저장 에러 발생');
          return false;
        });

      /** -- pk, sk로 암, 복호화 테스트 -> 성공 */
      // console.log(mac)
      // const privateKey = `${sk 넣기} `;
      // var decrypt = new JSEncrypt();
      // decrypt.setPrivateKey(privateKey);
      // var uncrypted = decrypt.decrypt(encrypted);
      // console.log('Decrypted:', uncrypted);
    };

    // pk
    getPkData().then(res => {
      serverPk = res;
      hashData(macAddr, serverPk, saltItem);
    });

    /** 초기 등록 */
    const initEncrypte = () => { };

    /** 검증 및 키 요청 */
    const verify = async () => {
      // 중복 제거 필요
      await getdata().then(res => {
        aes256Decode(res, secretKey, saltItem);
        console.log(decodeStr);
        macAddr = res;
      });
      const sha3Hash = await getHash2sha3(macAddr, saltItem);
      console.log('해시:',sha3Hash);

      let newHash = null;
      let newRandomKey2 = null;
      const localEncryptedId = localStorage.getItem('encryptedId');
      // router post => id and 암호화 키 요청
      await fetch('http://localhost:3002/getSecretKey', {
        method: 'POST',
        body: JSON.stringify({
          id: localEncryptedId
        }),
        headers: {
          'Content-Type': 'application/json'
        }
      })
        .then(response => response.json())
        .then(res => {
          console.log('서버로부터 받은 새 암호키', res.newSecretKey);
          // 기존 해시 값 + 서버로부터 받은 새 암호키 => 새로운 해시값 생성
          const getNewSha3Hash = getHash2sha3(sha3Hash+res.newSecretKey, saltItem);

          getNewSha3Hash
            .then(res => {
              console.log("");
              console.log('새 해시값', res);
              newHash = res;
            })
            .finally(() => {
              newRandomKey2 = 'KU3dxtykeejlj0J5HwKVnGrPSNR05jwV';
              console.log("");
              console.group('newHash & newSecretKey')
              console.log(newHash);
              console.log(newRandomKey2);
              console.groupEnd();

              fetch('http://localhost:3002/getNewHash', {
                method: 'POST',
                body: JSON.stringify({
                  hash: newHash,
                  newRandomKey2: newRandomKey2
                }),
                headers: {
                  "Content-Type": "application/json"
                }
              })
                .then(response => response.json())
                .then(res => {
                  console.log(res);
                  const { newR2Hash, cipherStr } = res;

                  const existHash = CryptoJS.SHA3(sha3Hash + newRandomKey2 + saltItem, { outputLength: 256 }).toString(CryptoJS.enc.Hex);
                  if (newR2Hash === existHash) {
                    console.log('웹페이지 신뢰 ok');
                    
                    /** aes 디코딩 */
                    const decryptCipher = CryptoJS.AES.decrypt(
                      cipherStr,
                      CryptoJS.enc.Utf8.parse(sha3Hash),
                      {
                        iv: CryptoJS.enc.Utf8.parse(saltItem),
                        padding: CryptoJS.pad.Pkcs7,
                        mode: CryptoJS.mode.CBC,
                      }
                    );
                    originSecretKey = decryptCipher.toString(CryptoJS.enc.Utf8);
                    console.log('originSecretKey:', originSecretKey);

                    saveLocalStorage('hg14699');
                  } else {
                    console.log('웹페이지 신뢰 no');
                  }
                })
                .catch(err => console.log('새 해시값 전달 실패', err));
            });
        });
    };

    // 임시
    // encryptedId가 있을 경우
    if (localStorage.getItem('encryptedId')) {
      verify();
    };

    const saveLocalStorage = (data) => {
      if(!originSecretKey) { 
        console.log('암호키 필요');
        return false; 
      };
      const testCipher = CryptoJS.AES.encrypt(
        data,
        CryptoJS.enc.Utf8.parse(originSecretKey),
        {
          iv: CryptoJS.enc.Utf8.parse(saltItem),
          padding: CryptoJS.pad.Pkcs7,
          mode: CryptoJS.mode.CBC
        }
      );
      localStorage.setItem('enc(Data)', testCipher.toString());
      console.log(localStorage.getItem('enc(Data)'));
      LoadLocalStorageData();
    }

    const LoadLocalStorageData = async () => {
      if(!originSecretKey) { 
        console.log('암호키 필요');
        return false; 
      };

      const testCipher = await CryptoJS.AES.decrypt(
        localStorage.getItem('enc(Data)'),
        CryptoJS.enc.Utf8.parse(originSecretKey),
        {
          iv: CryptoJS.enc.Utf8.parse(saltItem),
          padding: CryptoJS.pad.Pkcs7,
          mode: CryptoJS.mode.CBC
        }
      );
      console.log(testCipher.toString(CryptoJS.enc.Utf8));
    };
    
  </script>
</body>

</html>